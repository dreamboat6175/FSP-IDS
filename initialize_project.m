%% setup_project.m - 项目初始化脚本
% =========================================================================
% 描述: 创建项目目录结构并生成必要的辅助文件
% =========================================================================

function setup_project()
    fprintf('正在初始化FSP-TCS项目...\n');
    
    % 1. 创建目录结构
    dirs = {
        'config',          % 配置文件
        'core',            % 核心模块
        'agents',          % 智能体实现
        'utils',           % 工具函数
        'visualization',   % 可视化模块
        'models',          % 保存的模型
        'results',         % 仿真结果
        'reports',         % 报告输出
        'logs',            % 日志文件
        'data',            % 数据文件
        'checkpoints'      % 检查点
    };
    
    for i = 1:length(dirs)
        if ~exist(dirs{i}, 'dir')
            mkdir(dirs{i});
            fprintf('  ✓ 创建目录: %s\n', dirs{i});
        end
    end
    
    % 2. 生成默认配置文件
    generate_default_config();
    
    % 3. 创建其他必要的文件
    create_utility_files();
    
    % 4. 创建README文件
    create_readme();
    
    fprintf('\n项目初始化完成！\n');
    fprintf('运行 main_fsp_simulation.m 开始仿真\n');
end

function generate_default_config()
    % 生成默认配置JSON文件
    config = ConfigManager.getDefaultConfig();
    
    % 保存为JSON
    config_json = jsonencode(config, 'PrettyPrint', true);
    fid = fopen('config/default_config.json', 'w');
    fprintf(fid, '%s', config_json);
    fclose(fid);
    
    fprintf('  ✓ 生成默认配置: config/default_config.json\n');
end

function create_utility_files()
    % 创建工具类文件
    
    % 1. Logger类
    create_logger_class();
    
    % 2. AgentFactory类
    create_agent_factory();
    
    % 3. 其他智能体类
    create_sarsa_agent();
    create_double_q_agent();
    
    % 4. 可视化工具
    create_report_generator();
    
    % 5. 数据管理工具
    create_data_manager();
    
    % 6. 并行计算工具
    create_parallel_computing();
end

function create_logger_class()
    % 创建Logger类
    
    % 确保utils目录存在
    if ~exist('utils', 'dir')
        mkdir('utils');
    end
    
    code = [...
    '%% Logger.m - 日志记录器类\n' ...
    'classdef Logger < handle\n' ...
    '    properties\n' ...
    '        log_file\n' ...
    '        fid\n' ...
    '        log_level\n' ...
    '    end\n' ...
    '    \n' ...
    '    methods\n' ...
    '        function obj = Logger(log_file, log_level)\n' ...
    '            if nargin < 2\n' ...
    '                log_level = ''INFO'';\n' ...
    '            end\n' ...
    '            obj.log_file = log_file;\n' ...
    '            obj.log_level = log_level;\n' ...
    '            \n' ...
    '            % 确保日志目录存在\n' ...
    '            [log_dir, ~, ~] = fileparts(log_file);\n' ...
    '            if ~exist(log_dir, ''dir'')\n' ...
    '                mkdir(log_dir);\n' ...
    '            end\n' ...
    '            \n' ...
    '            obj.fid = fopen(log_file, ''a'');\n' ...
    '            if obj.fid == -1\n' ...
    '                error(''无法创建日志文件: %s'', log_file);\n' ...
    '            end\n' ...
    '            obj.info(''日志系统初始化'');\n' ...
    '        end\n' ...
    '        \n' ...
    '        function log(obj, level, message)\n' ...
    '            timestamp = datestr(now, ''yyyy-mm-dd HH:MM:SS'');\n' ...
    '            fprintf(obj.fid, ''[%s] [%s] %s\\n'', timestamp, level, message);\n' ...
    '            fprintf(''[%s] %s\\n'', level, message);\n' ...
    '        end\n' ...
    '        \n' ...
    '        function info(obj, message)\n' ...
    '            obj.log(''INFO'', message);\n' ...
    '        end\n' ...
    '        \n' ...
    '        function warning(obj, message)\n' ...
    '            obj.log(''WARNING'', message);\n' ...
    '        end\n' ...
    '        \n' ...
    '        function error(obj, message)\n' ...
    '            obj.log(''ERROR'', message);\n' ...
    '        end\n' ...
    '        \n' ...
    '        function delete(obj)\n' ...
    '            if obj.fid ~= -1\n' ...
    '                fclose(obj.fid);\n' ...
    '            end\n' ...
    '        end\n' ...
    '    end\n' ...
    'end\n'];
    
    fid = fopen('utils/Logger.m', 'w');
    fprintf(fid, '%s', code);
    fclose(fid);
    fprintf('  ✓ 创建文件: utils/Logger.m\n');
end

function create_agent_factory()
    % 创建AgentFactory类
    
    % 确保utils目录存在
    if ~exist('utils', 'dir')
        mkdir('utils');
    end
    
    code = [...
    '%% AgentFactory.m - 智能体工厂类\n' ...
    'classdef AgentFactory\n' ...
    '    methods (Static)\n' ...
    '        function agents = createDefenderAgents(config, env)\n' ...
    '            agents = {};\n' ...
    '            for i = 1:length(config.algorithms)\n' ...
    '                switch config.algorithms{i}\n' ...
    '                    case ''Q-Learning''\n' ...
    '                        agents{i} = QLearningAgent(sprintf(''Q-Learning-%d'', i), ...\n' ...
    '                                                  ''defender'', config, ...\n' ...
    '                                                  env.state_dim, env.action_dim_defender);\n' ...
    '                    case ''SARSA''\n' ...
    '                        agents{i} = SARSAAgent(sprintf(''SARSA-%d'', i), ...\n' ...
    '                                             ''defender'', config, ...\n' ...
    '                                             env.state_dim, env.action_dim_defender);\n' ...
    '                    case ''Double Q-Learning''\n' ...
    '                        agents{i} = DoubleQLearningAgent(sprintf(''DoubleQ-%d'', i), ...\n' ...
    '                                                       ''defender'', config, ...\n' ...
    '                                                       env.state_dim, env.action_dim_defender);\n' ...
    '                    otherwise\n' ...
    '                        error(''未知算法类型: %s'', config.algorithms{i});\n' ...
    '                end\n' ...
    '            end\n' ...
    '        end\n' ...
    '        \n' ...
    '        function agent = createAttackerAgent(config, env)\n' ...
    '            agent = QLearningAgent(''Attacker'', ''attacker'', config, ...\n' ...
    '                                 env.state_dim, env.action_dim_attacker);\n' ...
    '        end\n' ...
    '    end\n' ...
    'end\n'];
    
    fid = fopen('utils/AgentFactory.m', 'w');
    fprintf(fid, '%s', code);
    fclose(fid);
    fprintf('  ✓ 创建文件: utils/AgentFactory.m\n');
end

function create_sarsa_agent()
    % 创建SARSA智能体类
    
    % 确保agents目录存在
    if ~exist('agents', 'dir')
        mkdir('agents');
    end
    
    code = [...
    '%% SARSAAgent.m - SARSA智能体实现\n' ...
    'classdef SARSAAgent < RLAgent\n' ...
    '    properties\n' ...
    '        Q_table\n' ...
    '        visit_count\n' ...
    '    end\n' ...
    '    \n' ...
    '    methods\n' ...
    '        function obj = SARSAAgent(name, agent_type, config, state_dim, action_dim)\n' ...
    '            obj@RLAgent(name, agent_type, config, state_dim, action_dim);\n' ...
    '            obj.Q_table = zeros(state_dim, action_dim);\n' ...
    '            obj.visit_count = zeros(state_dim, action_dim);\n' ...
    '            obj.Q_table = obj.Q_table + randn(state_dim, action_dim) * 0.01;\n' ...
    '            obj.use_softmax = true;\n' ...
    '        end\n' ...
    '        \n' ...
    '        function action = selectAction(obj, state)\n' ...
    '            q_values = obj.Q_table(state, :);\n' ...
    '            action = obj.boltzmannAction(state, q_values);\n' ...
    '            obj.recordAction(state, action);\n' ...
    '        end\n' ...
    '        \n' ...
    '        function update(obj, state, action, reward, next_state, next_action)\n' ...
    '            if isempty(next_action)\n' ...
    '                next_action = obj.selectAction(next_state);\n' ...
    '            end\n' ...
    '            td_error = reward + obj.discount_factor * obj.Q_table(next_state, next_action) ...\n' ...
    '                       - obj.Q_table(state, action);\n' ...
    '            obj.Q_table(state, action) = obj.Q_table(state, action) + ...\n' ...
    '                                       obj.learning_rate * td_error;\n' ...
    '            obj.visit_count(state, action) = obj.visit_count(state, action) + 1;\n' ...
    '            obj.recordReward(reward);\n' ...
    '            obj.update_count = obj.update_count + 1;\n' ...
    '        end\n' ...
    '        \n' ...
    '        function policy = getPolicy(obj)\n' ...
    '            policy = obj.Q_table;\n' ...
    '        end\n' ...
    '        \n' ...
    '        function save(obj, filename)\n' ...
    '            if nargin < 2\n' ...
    '                filename = sprintf(''models/sarsa_%s_%s.mat'', ...\n' ...
    '                                 obj.agent_type, datestr(now, ''yyyymmdd_HHMMSS''));\n' ...
    '            end\n' ...
    '            [filepath, ~, ~] = fileparts(filename);\n' ...
    '            if ~exist(filepath, ''dir'')\n' ...
    '                mkdir(filepath);\n' ...
    '            end\n' ...
    '            save_data.Q_table = obj.Q_table;\n' ...
    '            save_data.visit_count = obj.visit_count;\n' ...
    '            save_data.name = obj.name;\n' ...
    '            save_data.agent_type = obj.agent_type;\n' ...
    '            save_data.update_count = obj.update_count;\n' ...
    '            save(filename, ''save_data'');\n' ...
    '        end\n' ...
    '        \n' ...
    '        function load(obj, filename)\n' ...
    '            if exist(filename, ''file'')\n' ...
    '                load_data = load(filename);\n' ...
    '                save_data = load_data.save_data;\n' ...
    '                obj.Q_table = save_data.Q_table;\n' ...
    '                obj.visit_count = save_data.visit_count;\n' ...
    '                obj.name = save_data.name;\n' ...
    '                obj.update_count = save_data.update_count;\n' ...
    '            else\n' ...
    '                error(''模型文件不存在: %s'', filename);\n' ...
    '            end\n' ...
    '        end\n' ...
    '    end\n' ...
    'end\n'];
    
    fid = fopen('agents/SARSAAgent.m', 'w');
    fprintf(fid, '%s', code);
    fclose(fid);
    fprintf('  ✓ 创建文件: agents/SARSAAgent.m\n');
end

function create_double_q_agent()
    % 创建Double Q-Learning智能体类（简化版）
    
    % 确保agents目录存在
    if ~exist('agents', 'dir')
        mkdir('agents');
    end
    
    code = [...
    '%% DoubleQLearningAgent.m - Double Q-Learning智能体实现\n' ...
    'classdef DoubleQLearningAgent < RLAgent\n' ...
    '    properties\n' ...
    '        Q1_table\n' ...
    '        Q2_table\n' ...
    '        visit_count\n' ...
    '    end\n' ...
    '    \n' ...
    '    methods\n' ...
    '        function obj = DoubleQLearningAgent(name, agent_type, config, state_dim, action_dim)\n' ...
    '            obj@RLAgent(name, agent_type, config, state_dim, action_dim);\n' ...
    '            obj.Q1_table = zeros(state_dim, action_dim) + randn(state_dim, action_dim) * 0.01;\n' ...
    '            obj.Q2_table = zeros(state_dim, action_dim) + randn(state_dim, action_dim) * 0.01;\n' ...
    '            obj.visit_count = zeros(state_dim, action_dim);\n' ...
    '        end\n' ...
    '        \n' ...
    '        function action = selectAction(obj, state)\n' ...
    '            Q_combined = (obj.Q1_table + obj.Q2_table) / 2;\n' ...
    '            q_values = Q_combined(state, :);\n' ...
    '            action = obj.epsilonGreedyAction(state, q_values);\n' ...
    '            obj.recordAction(state, action);\n' ...
    '        end\n' ...
    '        \n' ...
    '        function update(obj, state, action, reward, next_state, ~)\n' ...
    '            if rand() < 0.5\n' ...
    '                [~, best_action] = max(obj.Q1_table(next_state, :));\n' ...
    '                td_error = reward + obj.discount_factor * obj.Q2_table(next_state, best_action) ...\n' ...
    '                          - obj.Q1_table(state, action);\n' ...
    '                obj.Q1_table(state, action) = obj.Q1_table(state, action) + ...\n' ...
    '                                            obj.learning_rate * td_error;\n' ...
    '            else\n' ...
    '                [~, best_action] = max(obj.Q2_table(next_state, :));\n' ...
    '                td_error = reward + obj.discount_factor * obj.Q1_table(next_state, best_action) ...\n' ...
    '                          - obj.Q2_table(state, action);\n' ...
    '                obj.Q2_table(state, action) = obj.Q2_table(state, action) + ...\n' ...
    '                                            obj.learning_rate * td_error;\n' ...
    '            end\n' ...
    '            obj.visit_count(state, action) = obj.visit_count(state, action) + 1;\n' ...
    '            obj.recordReward(reward);\n' ...
    '            obj.update_count = obj.update_count + 1;\n' ...
    '        end\n' ...
    '        \n' ...
    '        function policy = getPolicy(obj)\n' ...
    '            policy = (obj.Q1_table + obj.Q2_table) / 2;\n' ...
    '        end\n' ...
    '        \n' ...
    '        function save(obj, filename)\n' ...
    '            if nargin < 2\n' ...
    '                filename = sprintf(''models/doubleq_%s_%s.mat'', ...\n' ...
    '                                 obj.agent_type, datestr(now, ''yyyymmdd_HHMMSS''));\n' ...
    '            end\n' ...
    '            [filepath, ~, ~] = fileparts(filename);\n' ...
    '            if ~exist(filepath, ''dir'')\n' ...
    '                mkdir(filepath);\n' ...
    '            end\n' ...
    '            save_data.Q1_table = obj.Q1_table;\n' ...
    '            save_data.Q2_table = obj.Q2_table;\n' ...
    '            save_data.visit_count = obj.visit_count;\n' ...
    '            save_data.name = obj.name;\n' ...
    '            save(filename, ''save_data'');\n' ...
    '        end\n' ...
    '        \n' ...
    '        function load(obj, filename)\n' ...
    '            if exist(filename, ''file'')\n' ...
    '                load_data = load(filename);\n' ...
    '                save_data = load_data.save_data;\n' ...
    '                obj.Q1_table = save_data.Q1_table;\n' ...
    '                obj.Q2_table = save_data.Q2_table;\n' ...
    '                obj.visit_count = save_data.visit_count;\n' ...
    '                obj.name = save_data.name;\n' ...
    '            else\n' ...
    '                error(''模型文件不存在: %s'', filename);\n' ...
    '            end\n' ...
    '        end\n' ...
    '    end\n' ...
    'end\n'];
    
    fid = fopen('agents/DoubleQLearningAgent.m', 'w');
    fprintf(fid, '%s', code);
    fclose(fid);
    fprintf('  ✓ 创建文件: agents/DoubleQLearningAgent.m\n');
end

function create_report_generator()
    % 创建ReportGenerator类（简化版）
    
    % 确保visualization目录存在
    if ~exist('visualization', 'dir')
        mkdir('visualization');
    end
    
    code = [...
    '%% ReportGenerator.m - 报告生成器类\n' ...
    'classdef ReportGenerator\n' ...
    '    methods (Static)\n' ...
    '        function generateFullReport(results, config, agents, env)\n' ...
                '            % 生成完整报告\n' ...
    '            timestamp = datestr(now, ''yyyymmdd_HHMMSS'');\n' ...
    '            \n' ...
    '            % 生成可视化报告\n' ...
    '            ReportGenerator.generateVisualReport(results, config, agents);\n' ...
    '            \n' ...
    '            % 生成文本报告\n' ...
    '            ReportGenerator.generateTextReport(results, config, agents, timestamp);\n' ...
    '            \n' ...
    '            % 生成性能对比表\n' ...
    '            ReportGenerator.generateComparisonTable(results, agents);\n' ...
    '        end\n' ...
    '        \n' ...
    '        function generateVisualReport(results, config, agents)\n' ...
    '            figure(''Position'', [50, 50, 1400, 900], ''Name'', ''FSP仿真报告'');\n' ...
    '            \n' ...
    '            % 检测率对比\n' ...
    '            subplot(2, 2, 1);\n' ...
    '            ReportGenerator.plotDetectionRates(results, agents);\n' ...
    '            \n' ...
    '            % 资源利用率\n' ...
    '            subplot(2, 2, 2);\n' ...
    '            ReportGenerator.plotResourceUtilization(results, agents);\n' ...
    '            \n' ...
    '            % 收敛性分析\n' ...
    '            subplot(2, 2, 3);\n' ...
    '            ReportGenerator.plotConvergence(results, agents);\n' ...
    '            \n' ...
    '            % 攻击模式分析\n' ...
    '            subplot(2, 2, 4);\n' ...
    '            ReportGenerator.plotAttackPatterns(results);\n' ...
    '            \n' ...
    '            % 保存图表\n' ...
    '            saveas(gcf, sprintf(''reports/visual_report_%s.png'', ...\n' ...
    '                              datestr(now, ''yyyymmdd_HHMMSS'')));\n' ...
    '        end\n' ...
    '        \n' ...
    '        function plotDetectionRates(results, agents)\n' ...
    '            hold on;\n' ...
    '            colors = lines(results.n_agents);\n' ...
    '            legend_names = {};\n' ...
    '            for i = 1:results.n_agents\n' ...
    '                plot(1:results.n_iterations, results.detection_rates(i, :), ...\n' ...
    '                     ''Color'', colors(i,:), ''LineWidth'', 2);\n' ...
    '                if isfield(agents, ''defenders'')\n' ...
    '                    legend_names{i} = agents.defenders{i}.name;\n' ...
    '                else\n' ...
    '                    legend_names{i} = sprintf(''Agent %d'', i);\n' ...
    '                end\n' ...
    '            end\n' ...
    '            xlabel(''迭代次数'');\n' ...
    '            ylabel(''检测率'');\n' ...
    '            title(''不同算法检测率对比'');\n' ...
    '            legend(legend_names, ''Location'', ''best'');\n' ...
    '            grid on;\n' ...
    '        end\n' ...
    '        \n' ...
    '        function plotResourceUtilization(results, agents)\n' ...
    '            hold on;\n' ...
    '            colors = lines(results.n_agents);\n' ...
    '            legend_names = {};\n' ...
    '            for i = 1:results.n_agents\n' ...
    '                plot(1:results.n_iterations, results.resource_utilization(i, :), ...\n' ...
    '                     ''Color'', colors(i,:), ''LineWidth'', 2);\n' ...
    '                if isfield(agents, ''defenders'')\n' ...
    '                    legend_names{i} = agents.defenders{i}.name;\n' ...
    '                else\n' ...
    '                    legend_names{i} = sprintf(''Agent %d'', i);\n' ...
    '                end\n' ...
    '            end\n' ...
    '            xlabel(''迭代次数'');\n' ...
    '            ylabel(''资源利用率'');\n' ...
    '            title(''资源利用效率对比'');\n' ...
    '            legend(legend_names, ''Location'', ''best'');\n' ...
    '            grid on;\n' ...
    '        end\n' ...
    '        \n' ...
    '        function plotConvergence(results, agents)\n' ...
    '            valid_idx = 11:results.n_iterations;\n' ...
    '            colors = lines(results.n_agents);\n' ...
    '            legend_names = {};\n' ...
    '            for i = 1:results.n_agents\n' ...
    '                semilogy(valid_idx, results.convergence_metrics(i, valid_idx), ...\n' ...
    '                        ''Color'', colors(i,:), ''LineWidth'', 2);\n' ...
    '                hold on;\n' ...
    '                if isfield(agents, ''defenders'')\n' ...
    '                    legend_names{i} = agents.defenders{i}.name;\n' ...
    '                else\n' ...
    '                    legend_names{i} = sprintf(''Agent %d'', i);\n' ...
    '                end\n' ...
    '            end\n' ...
    '            xlabel(''迭代次数'');\n' ...
    '            ylabel(''策略变化标准差 (对数尺度)'');\n' ...
    '            title(''策略收敛性分析'');\n' ...
    '            legend(legend_names, ''Location'', ''best'');\n' ...
    '            grid on;\n' ...
    '        end\n' ...
    '        \n' ...
    '        function plotAttackPatterns(results)\n' ...
    '            attack_sum = sum(results.attack_type_stats, 2);\n' ...
    '            pie(attack_sum);\n' ...
    '            title(''攻击类型分布'');\n' ...
    '        end\n' ...
    '        \n' ...
    '        function generateTextReport(results, config, agents, timestamp)\n' ...
    '            filename = sprintf(''reports/text_report_%s.txt'', timestamp);\n' ...
    '            fid = fopen(filename, ''w'');\n' ...
    '            \n' ...
    '            fprintf(fid, ''FSP列控系统入侵检测仿真报告\\n'');\n' ...
    '            fprintf(fid, ''生成时间: %s\\n\\n'', datestr(now));\n' ...
    '            \n' ...
    '            fprintf(fid, ''配置信息:\\n'');\n' ...
    '            fprintf(fid, ''- 主站数量: %d\\n'', config.n_stations);\n' ...
    '            fprintf(fid, ''- 迭代次数: %d\\n'', config.n_iterations);\n' ...
    '            fprintf(fid, ''- 算法: %s\\n\\n'', strjoin(config.algorithms, '', ''));\n' ...
    '            \n' ...
    '            fprintf(fid, ''性能指标:\\n'');\n' ...
    '            for i = 1:results.n_agents\n' ...
    '                avg_detection = mean(results.detection_rates(i, end-99:end));\n' ...
    '                fprintf(fid, ''%s:\\n'', agents.defenders{i}.name);\n' ...
    '                fprintf(fid, ''  - 平均检测率: %.2f%%\\n'', avg_detection * 100);\n' ...
    '            end\n' ...
    '            \n' ...
    '            fclose(fid);\n' ...
    '        end\n' ...
    '        \n' ...
    '        function generateComparisonTable(results, agents)\n' ...
    '            % 生成算法性能对比表\n' ...
    '            n_agents = results.n_agents;\n' ...
    '            metrics = {''检测率'', ''资源效率'', ''收敛性'', ''策略多样性''};\n' ...
    '            \n' ...
    '            % 计算各项指标\n' ...
    '            data = zeros(n_agents, length(metrics));\n' ...
    '            for i = 1:n_agents\n' ...
    '                data(i, 1) = mean(results.detection_rates(i, end-99:end));\n' ...
    '                data(i, 2) = mean(results.resource_utilization(i, end-99:end));\n' ...
    '                data(i, 3) = mean(results.convergence_metrics(i, end-99:end));\n' ...
    '                data(i, 4) = mean(results.strategy_diversity(i, results.strategy_diversity(i,:)>0));\n' ...
    '            end\n' ...
    '            \n' ...
    '            % 创建表格\n' ...
    '            T = array2table(data, ...\n' ...
    '                          ''VariableNames'', metrics, ...\n' ...
    '                          ''RowNames'', {agents.defenders{:}.name});\n' ...
    '            \n' ...
    '            % 保存表格\n' ...
    '            writetable(T, sprintf(''reports/comparison_table_%s.csv'', ...\n' ...
    '                                datestr(now, ''yyyymmdd_HHMMSS'')), ...\n' ...
    '                     ''WriteRowNames'', true);\n' ...
    '        end\n' ...
    '    end\n' ...
    'end\n'];
    
    fid = fopen('visualization/ReportGenerator.m', 'w');
    fprintf(fid, '%s', code);
    fclose(fid);
    fprintf('  ✓ 创建文件: visualization/ReportGenerator.m\n');
end

function create_data_manager()
    % 创建DataManager类
    
    % 确保utils目录存在
    if ~exist('utils', 'dir')
        mkdir('utils');
    end
    
    code = [...
    '%% DataManager.m - 数据管理器类\n' ...
    'classdef DataManager\n' ...
    '    methods (Static)\n' ...
    '        function saveResults(results, config, agents)\n' ...
    '            % 保存仿真结果\n' ...
    '            timestamp = datestr(now, ''yyyymmdd_HHMMSS'');\n' ...
    '            filename = sprintf(''results/fsp_results_%s.mat'', timestamp);\n' ...
    '            \n' ...
    '            % 整理数据\n' ...
    '            save_data.results = results;\n' ...
    '            save_data.config = config;\n' ...
    '            save_data.timestamp = now;\n' ...
    '            save_data.matlab_version = version;\n' ...
    '            \n' ...
    '            % 保存智能体策略\n' ...
    '            save_data.policies = {};\n' ...
    '            save_data.agent_names = {};\n' ...
    '            for i = 1:length(agents.defenders)\n' ...
    '                save_data.policies{i} = agents.defenders{i}.getPolicy();\n' ...
    '                save_data.agent_names{i} = agents.defenders{i}.name;\n' ...
    '            end\n' ...
    '            \n' ...
    '            % 保存攻击者策略\n' ...
    '            save_data.attacker_policy = agents.attacker.getPolicy();\n' ...
    '            \n' ...
    '            % 保存文件\n' ...
    '            save(filename, ''save_data'', ''-v7.3'');\n' ...
    '            fprintf(''✓ 结果已保存: %s\\n'', filename);\n' ...
    '            \n' ...
    '            % 导出关键数据为CSV\n' ...
    '            DataManager.exportToCSV(results, timestamp);\n' ...
    '        end\n' ...
    '        \n' ...
    '        function data = loadResults(filename)\n' ...
    '            % 加载仿真结果\n' ...
    '            if exist(filename, ''file'')\n' ...
    '                loaded = load(filename);\n' ...
    '                data = loaded.save_data;\n' ...
    '                fprintf(''✓ 结果已加载: %s\\n'', filename);\n' ...
    '            else\n' ...
    '                error(''文件不存在: %s'', filename);\n' ...
    '            end\n' ...
    '        end\n' ...
    '        \n' ...
    '        function exportToCSV(results, timestamp)\n' ...
    '            % 导出关键数据为CSV格式\n' ...
    '            \n' ...
    '            % 检测率数据\n' ...
    '            detection_table = array2table(results.detection_rates'', ...\n' ...
    '                                        ''VariableNames'', arrayfun(@(x) sprintf(''Agent_%d'', x), ...\n' ...
    '                                                                  1:results.n_agents, ...\n' ...
    '                                                                  ''UniformOutput'', false));\n' ...
    '            writetable(detection_table, ...\n' ...
    '                      sprintf(''results/detection_rates_%s.csv'', timestamp));\n' ...
    '            \n' ...
    '            % 资源利用率数据\n' ...
    '            resource_table = array2table(results.resource_utilization'', ...\n' ...
    '                                       ''VariableNames'', arrayfun(@(x) sprintf(''Agent_%d'', x), ...\n' ...
    '                                                                 1:results.n_agents, ...\n' ...
    '                                                                 ''UniformOutput'', false));\n' ...
    '            writetable(resource_table, ...\n' ...
    '                      sprintf(''results/resource_utilization_%s.csv'', timestamp));\n' ...
    '        end\n' ...
    '        \n' ...
    '        function mergeResults(filenames)\n' ...
    '            % 合并多次仿真的结果\n' ...
    '            merged_data = [];\n' ...
    '            \n' ...
    '            for i = 1:length(filenames)\n' ...
    '                data = DataManager.loadResults(filenames{i});\n' ...
    '                if isempty(merged_data)\n' ...
    '                    merged_data = data;\n' ...
    '                else\n' ...
    '                    % 合并逻辑\n' ...
    '                    merged_data.results.detection_rates = ...\n' ...
    '                        [merged_data.results.detection_rates, data.results.detection_rates];\n' ...
    '                end\n' ...
    '            end\n' ...
    '            \n' ...
    '            % 保存合并结果\n' ...
    '            timestamp = datestr(now, ''yyyymmdd_HHMMSS'');\n' ...
    '            save(sprintf(''results/merged_results_%s.mat'', timestamp), ''merged_data'');\n' ...
    '        end\n' ...
    '    end\n' ...
    'end\n'];
    
    fid = fopen('utils/DataManager.m', 'w');
    fprintf(fid, '%s', code);
    fclose(fid);
    fprintf('  ✓ 创建文件: utils/DataManager.m\n');
end

function create_parallel_computing()
    % 创建ParallelComputing类
    
    % 确保utils目录存在
    if ~exist('utils', 'dir')
        mkdir('utils');
    end
    
    code = [...
    '%% ParallelComputing.m - 并行计算支持类\n' ...
    'classdef ParallelComputing\n' ...
    '    methods (Static)\n' ...
    '        function setup()\n' ...
    '            % 设置并行计算环境\n' ...
    '            if license(''test'', ''Distrib_Computing_Toolbox'')\n' ...
    '                pool = gcp(''nocreate'');\n' ...
    '                if isempty(pool)\n' ...
    '                    % 获取可用核心数\n' ...
    '                    num_cores = feature(''numcores'');\n' ...
    '                    % 使用核心数-1，保留一个核心给系统\n' ...
    '                    num_workers = max(1, num_cores - 1);\n' ...
    '                    \n' ...
    '                    try\n' ...
    '                        parpool(''local'', num_workers);\n' ...
    '                        fprintf(''✓ 并行计算池已启动，使用 %d 个工作进程\\n'', num_workers);\n' ...
    '                    catch ME\n' ...
    '                        warning(''无法启动并行池: %s'', ME.message);\n' ...
    '                        fprintf(''将使用单线程模式\\n'');\n' ...
    '                    end\n' ...
    '                else\n' ...
    '                    fprintf(''✓ 并行计算池已存在，使用 %d 个工作进程\\n'', pool.NumWorkers);\n' ...
    '                end\n' ...
    '            else\n' ...
    '                fprintf(''未检测到并行计算工具箱，使用单线程模式\\n'');\n' ...
    '            end\n' ...
    '        end\n' ...
    '        \n' ...
    '        function cleanup()\n' ...
    '            % 清理并行计算资源\n' ...
    '            pool = gcp(''nocreate'');\n' ...
    '            if ~isempty(pool)\n' ...
    '                delete(pool);\n' ...
    '                fprintf(''并行计算池已关闭\\n'');\n' ...
    '            end\n' ...
    '        end\n' ...
    '        \n' ...
    '        function result = parallelRun(func, data, options)\n' ...
    '            % 并行执行函数\n' ...
    '            if nargin < 3\n' ...
    '                options = struct();\n' ...
    '            end\n' ...
    '            \n' ...
    '            pool = gcp(''nocreate'');\n' ...
    '            if ~isempty(pool) && pool.NumWorkers > 1\n' ...
    '                % 使用并行计算\n' ...
    '                result = cell(length(data), 1);\n' ...
    '                parfor i = 1:length(data)\n' ...
    '                    result{i} = func(data{i});\n' ...
    '                end\n' ...
    '            else\n' ...
    '                % 串行计算\n' ...
    '                result = cell(length(data), 1);\n' ...
    '                for i = 1:length(data)\n' ...
    '                    result{i} = func(data{i});\n' ...
    '                end\n' ...
    '            end\n' ...
    '        end\n' ...
    '    end\n' ...
    'end\n'];
    
    fid = fopen('utils/ParallelComputing.m', 'w');
    fprintf(fid, '%s', code);
    fclose(fid);
    fprintf('  ✓ 创建文件: utils/ParallelComputing.m\n');
end

function create_readme()
    % 创建README文件
    readme_content = [...
    '# FSP-TCS 列控系统入侵检测资源分配仿真\n\n' ...
    '## 项目简介\n' ...
    '基于Fictitious Self-Play (FSP)框架的列控系统入侵检测资源分配博弈仿真系统。\n\n' ...
    '## 目录结构\n' ...
    '```\n' ...
    'FSP-TCS/\n' ...
    '├── main_fsp_simulation.m    # 主程序入口\n' ...
    '├── setup_project.m          # 项目初始化脚本\n' ...
    '├── config/                  # 配置文件目录\n' ...
    '│   ├── ConfigManager.m      # 配置管理器\n' ...
    '│   └── default_config.json  # 默认配置\n' ...
    '├── core/                    # 核心模块\n' ...
    '│   ├── TCSEnvironment.m     # 列控系统环境\n' ...
    '│   ├── FSPSimulator.m       # FSP仿真器\n' ...
    '│   └── PerformanceMonitor.m # 性能监控器\n' ...
    '├── agents/                  # 智能体实现\n' ...
    '│   ├── RLAgent.m           # 强化学习智能体基类\n' ...
    '│   ├── QLearningAgent.m    # Q-Learning智能体\n' ...
    '│   ├── SARSAAgent.m        # SARSA智能体\n' ...
    '│   └── DoubleQLearningAgent.m # Double Q-Learning智能体\n' ...
    '├── utils/                   # 工具函数\n' ...
    '│   ├── Logger.m            # 日志记录器\n' ...
    '│   ├── AgentFactory.m      # 智能体工厂\n' ...
    '│   ├── DataManager.m       # 数据管理器\n' ...
    '│   └── ParallelComputing.m # 并行计算支持\n' ...
    '├── visualization/           # 可视化模块\n' ...
    '│   └── ReportGenerator.m   # 报告生成器\n' ...
    '├── results/                # 仿真结果\n' ...
    '├── reports/                # 生成的报告\n' ...
    '├── logs/                   # 日志文件\n' ...
    '├── models/                 # 保存的模型\n' ...
    '└── checkpoints/            # 检查点\n' ...
    '```\n\n' ...
    '## 快速开始\n\n' ...
    '### 1. 初始化项目\n' ...
    '```matlab\n' ...
    'setup_project()\n' ...
    '```\n\n' ...
    '### 2. 运行仿真\n' ...
    '```matlab\n' ...
    'main_fsp_simulation\n' ...
    '```\n\n' ...
    '### 3. 自定义配置\n' ...
    '编辑 `config/default_config.json` 或创建新的配置文件。\n\n' ...
    '## 主要功能\n\n' ...
    '1. **多算法对比**：支持Q-Learning、SARSA、Double Q-Learning\n' ...
    '2. **FSP框架**：实现完整的Fictitious Self-Play迭代\n' ...
    '3. **性能监控**：实时监控检测率、资源利用率等指标\n' ...
    '4. **可视化报告**：自动生成图表和文本报告\n' ...
    '5. **并行计算**：支持多核并行加速\n' ...
    '6. **模块化设计**：易于扩展和维护\n\n' ...
    '## 配置说明\n\n' ...
    '主要配置参数：\n' ...
    '- `n_stations`: 主站数量\n' ...
    '- `n_iterations`: FSP迭代次数\n' ...
    '- `n_episodes_per_iter`: 每次迭代的episodes数\n' ...
    '- `learning_rate`: 学习率\n' ...
    '- `algorithms`: 使用的算法列表\n\n' ...
    '## 输出说明\n\n' ...
    '1. **实时监控**：迭代过程中显示进度和关键指标\n' ...
    '2. **可视化报告**：`reports/visual_report_*.png`\n' ...
    '3. **文本报告**：`reports/text_report_*.txt`\n' ...
    '4. **数据文件**：`results/fsp_results_*.mat`\n' ...
    '5. **CSV数据**：`results/*_*.csv`\n\n' ...
    '## 扩展开发\n\n' ...
    '### 添加新算法\n' ...
    '1. 在 `agents/` 目录创建新的智能体类，继承自 `RLAgent`\n' ...
    '2. 实现必要的抽象方法\n' ...
    '3. 在 `AgentFactory` 中注册新算法\n\n' ...
    '### 修改环境\n' ...
    '编辑 `TCSEnvironment.m` 以修改系统架构或攻击模型。\n\n' ...
    '## 注意事项\n\n' ...
    '1. 确保MATLAB版本支持所需功能\n' ...
    '2. 大规模仿真建议使用并行计算\n' ...
    '3. 定期保存检查点以防中断\n' ...
    '4. 根据内存情况调整仿真规模\n\n' ...
    '## 联系方式\n\n' ...
    'FSP-TCS研究团队\n' ...
    '更新日期：' datestr(now, 'yyyy-mm-dd') '\n'];
    
    fid = fopen('README.md', 'w');
    fprintf(fid, '%s', readme_content);
    fclose(fid);
    fprintf('  ✓ 创建文件: README.md\n');
end

% 运行设置脚本
setup_project();